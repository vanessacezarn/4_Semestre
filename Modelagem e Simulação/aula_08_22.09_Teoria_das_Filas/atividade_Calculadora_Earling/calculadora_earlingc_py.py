# -*- coding: utf-8 -*-
"""Calculadora_EarlingC.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I5llv9bVLfVmxCIb8EAjJgBd-B0Jzu1-
"""

# VANESSA CEZAR DO NASCIMENTO
"""
  Neste trabalho foi escolhido para o cálculo das métricas de desempenho do M/M/c
  a opção B disponibilizada no comando da atividade, ou seja, foram desenvolvidas várias
  funções, uma para o cálculo de cada uma das métricas, pois acredito que elas separadas
  geram uma maior organização do codigo, além de facilitar a reutilização e futuras manutenções.
  Utilização do programa:
  Entradas: possui duas entradas disponiveis, a primeira solicita que seja digitado o tráfego
            oferecido (a) e a quantidade de servidores (c), já a segunda entrada pede para
            digitar a taxa de chegada(λ), a taxa de atendimento por servidor(μ)e o número de
            servidores (c).
  Saidas: P(wait): probabilidade de um cliente precisar esperar na fila.
          ρ: utilização média por servidor.
          Wq: tempo médio de espera na fila.
          Lq: número médio de clientes na fila.
          W : tempo médio de permanência no sistema.
          L : número médio de clientes no sistema.
  Unidade: tempo em minutos.
  Validações: μ > 0 e c > 0
              Entradas numéricas (valores inválidos são tratados com mensagem)
              Caso a ≥ c, o programa considera o sistema instável P (wait) = 1 e informa que
             5 Wq, Lq, W, L → ∞.

"""
# -*- coding: utf-8 -*-
"""
Calculadora mínima de Erlang C (P(wait)) em M/M/c

Símbolos e fórmulas (todas no contexto M/M/c):
- λ (lambda): taxa de chegadas (clientes por unidade de tempo)
- μ (mi): taxa de atendimento de CADA servidor (clientes por unidade de tempo)
- c: número de servidores idênticos

Derivadas:
- a = λ/μ  (Erlangs)  → tráfego oferecido (carga média ofertada ao sistema)
- ρ = a/c = λ/(c μ)   → utilização média por servidor (0 < ρ < 1 para regime estável)

Fórmula de Erlang C (probabilidade de esperar na fila):
            (a^c / c!) * (c / (c − a))
P(wait) = ---------------------------------------------
          Σ_{n=0}^{c−1} (a^n / n!)  +  (a^c / c!) * (c / (c − a))

Observações:
- Estabilidade prática: a < c  (se a ≥ c, a fila “explode” e P(wait) → 1).
- Unidades de tempo em Wq e W são as mesmas usadas em λ e μ (min, h, ...).

A partir de P(wait), demais métricas (opcionais, mostradas aqui para referência):
- Wq = P(wait) / (c μ − λ)               (tempo médio de espera na fila)
- Lq = λ * Wq                             (número médio na fila — Little)
- W  = Wq + 1/μ                           (tempo médio no sistema)
- L  = λ * W                              (número médio no sistema — Little)

"""

from math import factorial

def erlang_c(a: float, c: int) -> float:
    """Retorna P(wait) dado o tráfego oferecido a=λ/μ (Erlangs) e c servidores.
    Observação: para estabilidade prática, é necessário a < c.
    """
    if a < 0 or c <= 0:
        raise ValueError("'a' deve ser >= 0 e 'c' > 0.")
    if a >= c:
        return 1.0  # sistema instável: P(wait) tende a 1

    #Formula: P(wait) = [ (a^c / c!) ×(c / (c -a)) ] / [ Σ(a^n / n!) + (a^c / c!) ×(c / (c -a)) ]
    soma = sum((a**n) / factorial(n) for n in range(c))        # Σ_{n=0}^{c-1} a^n/n!
    termo = (a**c) / factorial(c) * (c / (c - a))              # (a^c/c!) * (c/(c-a))
    return termo / (soma + termo)

def ler_float(msg: str) -> float:
    while True:
        try:
            return float(input(msg).replace(',', '.'))
        except ValueError:
            print('Valor inválido. Tente novamente.')

def ler_int(msg: str) -> int:
    while True:
        try:
            v = int(input(msg))
            if v <= 0:
                print('Digite um inteiro > 0.')
            else:
                return v
        except ValueError:
            print('Valor inválido. Tente novamente.')

def utilizacao_media_por_servidor (a, c):
    """ Função que calcula a utilização média por servidor (ρ)
        Recebe por parâmetro : a que é o tráfego oferecido a=λ/μ (Erlangs) e c servidores.
        retorna a utilização média por servidor ρ = a/c
    """
    rho = a / c
    return rho

def tempo_medio_da_espera_na_fila (p,c,mu,lam):
    """Função que calcular o tempo médio de espera na fila (Wq)
       Recebe por parâmetro: p que é o P(wait), ou seja, a probabilidade de um cliente ter que esperar
                             c que é o número de servidores
                             mu que é a taxa de atendimento por servidor (μ)
                             lam que é a taxa de chegadas (λ)
       Rertona o tempo médio de espera na fila (Wq)
    """
    Wq = p / (c * mu - lam)
    return Wq

def numero_medio_na_fila(p,c,mu,lam):
    """ Função que calcula o número médio na fila (Lq)
        Recebe por parâmetro: p que é o P(wait), ou seja, a probabilidade de um cliente ter que esperar
                             c que é o número de servidores
                             mu que é a taxa de atendimento por servidor (μ)
                             lam que é a taxa de chegadas (λ)
        Como o calculo depende do tempo médio de espera na fila (Wq), chama a função tempo_medio_da_espera_na_fila
        Rertona o número médio na fila (Lq)
    """
    Wq = tempo_medio_da_espera_na_fila(p,c,mu,lam)
    Lq = lam * Wq
    return Lq

def tempo_medio_no_sistema(p,c,mu,lam):
    """Função que calcular o tempo médio no sistema (W)
       Recebe por parâmetro: p que é o P(wait), ou seja, a probabilidade de um cliente ter que esperar
                             c que é o número de servidores.
                             mu que é a taxa de atendimento por servidor (μ)
                             lam que é a taxa de chegadas (λ)
       Como o caludo depende do tempo médio de espera na fila (Wq), chama a função tempo_medio_da_espera_na_fila
       Rertona o tempo médio no sistema (W)
    """
    Wq = tempo_medio_da_espera_na_fila(p,c,mu,lam)
    W = Wq + 1/mu
    return W

def numero_medio_no_sistema(p, c, mu,lam):
    """Função que calcular o número médio no sistema (L)
        Recebe por parâmetro: p que é o P(wait), ou seja, a probabilidade de um cliente ter que esperar
                              c que é o número de servidores.
                              mu que é a taxa de atendimento por servidor (μ)
                              lam que é a taxa de chegadas (λ)
       Como o caludo depende do tempo médio no sistema (W), chama a função tempo_medio_no_sistema
       Rertona o número médio no sistema (L)
    """
    W = tempo_medio_no_sistema(p,c,mu,lam)
    L = lam * W
    return L


def main():
    print('\n=== Calculadora Erlang C (P(wait)) ===')
    print('1) Entrar com a = λ/μ (Erlangs) e c')
    print('2) Entrar com λ, μ e c')
    opc = input('Escolha (1/2): ').strip()

    if opc == '1':
        a = ler_float('Informe a (λ/μ) em Erlangs: ')
        c = ler_int('Informe c (nº de servidores): ')
        lam = None
        mu = None
    elif opc == '2':
        lam = ler_float('Informe λ (taxa de chegadas): ')
        mu  = ler_float('Informe μ (taxa de atendimento por servidor): ')
        c   = ler_int('Informe c (nº de servidores): ')
        if mu <= 0:
            print('μ deve ser > 0. Encerrando.')
            return
        if c <= 0:
            print('c deve ser > 0. Encerrando.')
            return
        a = lam / mu
        print(f'a = λ/μ = {a:.6f} Erlangs')
    else:
        print('Opção inválida. Encerrando.')
        return

    p = erlang_c(a, c)
    print(f'\nP(wait) = {p:.6f}  (equivalente a {p*100:.2f}%)')
    if a >= c:
        print('Atenção: a ≥ c ⇒ sistema instável (fila explode).')
        print('Wq, W, Lq e L → ∞')
        print('Encerrando.')
        return
    else:
        print('Observação: estabilidade prática exige a < c.')

    print('\n\t MÉTRICAS DE DESEMPENHO M/M/c')
    print(f'Utilização média por servidor: {utilizacao_media_por_servidor(a, c):.3f}')
    if lam is not None and mu is not None:
        print(f'Tempo médio de espera na fila (Wq): {tempo_medio_da_espera_na_fila(p,c,mu,lam):.3f}')
        print(f'Número médio na fila (Lq): {numero_medio_na_fila(p, c, mu, lam):.3f}')
        print(f'Tempo médio no sistema(W): {tempo_medio_no_sistema(p,c,mu,lam):.3f}')
        print(f'Número médio no sistema(L): {numero_medio_no_sistema(p, c, mu,lam):.3f}')
    else:
        print("A taxa de chegada(λ) e a taxa de atendimento(μ) não estão disponíveis para calular algumas métrica")


if __name__ == '__main__':
    while True:
        main()
        denovo = input('\nDeseja calcular novamente? (s/n): ').strip().lower()
        if denovo != 's':
            print('Encerrado.')
            break